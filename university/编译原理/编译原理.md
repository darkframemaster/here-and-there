#编译原理复习笔记
## >>>>>>>>>>>>>>*Don't worry *>>>>>>>>>>>>>>>>
##一 编译器概述

**翻译器：**能够完成从一种语言到另一种语言的变换的软件。

**编译器：**一种翻译器，进行语言变换的特点是目标语言比源语言低级。

>####编译器与解释器的区别
>**编译器：**把源程序的每一句都编译成机器语言，并保存为二进制文件，所以运行效率高
>
>**解释器：**效率低，但是移植性高，把源程序先编译成一种中间语言，在需要的时候再实时译
>成机器语言

###编译的各个阶段：
>源代码->

>###前端**（分析阶段）**
>
>>**词法分析器**->记号流->
>>
>>**语法分析器**-> 语法树 ->
>>
>>**语义分析器**->语法树->**中间代码生成器**->中间表示->（这一整步通常视为语义分析）

>###后端**（综合阶段）**
>
>>**独立于机器的代码优化器**->中间表示->
>>
>>**代码生成器**->目标机器代码->
>>
>>**依赖于机器的代码优化器**->
>
>目标机器代码

**符号表**和**出错管理器**也参与到了这些过程中。

##二.词法分析
###目标：明白正规式所代表语言集的意义，NFA&DFA。

>串------集合------>语言

>词法单位------模式------>记号

**运算优先级：闭包>连接>选择**

**状态：**开始状态记得写**开始**，接受状态两个圈。

###2.1 不确定的有限自动机（nondeterministic finite automata，NFA）
* 状态集合S；
* 输入符号集合E；
* 转换函数;
* 状态s0是开始状态；
* F 包含于 S 内，是接受状态集合。

**构造NFA可以用公式（这里的公式就是利用yibuxilong的边构造选择，连接，闭包结构），也可以根据识别的内容直接来。**：一个快一个稳，建议两个都搞懂。

###2.2 确定的有限自动机(DFA)
* 状态集合S；
* 输入字母表；
* 转换函数；
* 唯一的初态 s 包含于 S 内；
* 终态集合F 包含于 S 内。

###2.3 *NFA->DFA*的转换
####子集构造法  这个比较稳
* 构造NFA
* 通过求闭包找到DFA初始状态
* 写出DFA状态转换表
* 画图

####子集构造法2  这个比较快
* 构造NFA
* DFA的一个状态是NFA的一个状态集合
* 读了输入a1 a2 … an后，NFA能到达的所有状态：s1, s2，…,sk，则DFA到达状态：{s1, s2, …,  sk}

###2.4 DFA化简
####集合拆分法
* 加入死状态，补全所有状态的输入与输出
* 将所有不可区分状态（非接受状态）视为一个集合，接受状态为一个集合
* 看集合中的所有状态通过同一个符号是不是能到达同一个状态（对所有符号都要执行），如果能不用拆分，如果不能则拆分那些有不同输出状态的状态，构成新的集合集。
* 迭代上一条
* 如果没有要拆的集合则到达了最简集合。

####从语言到确定的有限自动机
* 要识别的是什么
* 可能的状态有哪些
* 这些状态之间怎么转换

**ex:**识别能被5整除的2进制数。

##三. 语法分析
###3.1 上下文无关文法
上下文无关文法结构：**终结符，非终结符，开始符号，产生式**。

**最左推导，最右推导**

**产生式中用的是单箭头（->），推导中使用双箭头(=>)**

###二义性
有些文法的一些句子存在不止一棵分析树，或者说这些句子**不止一种最左（最右）推导**。

###消除二义性
**根据算符不同的优先级，引入新的非终结符。**


**ex:**

`E -> E + E | E * E | (E) | -E | id
`

转为非二义

`E ->  E + T | T`

`T -> T * F | F`

`F -> id | (E)`

###左递归
**自上而下的分析方法不能用于左递归文法，因此需要消除左递归**

####消除左递归
**ex:**

`A->Aa|b`

消除左递归：（这里用e代替yibuxilong）

`A->bA'`

`A'->aA'|e`

**ex:非直接左递归**

`S->Aa|b`

`A->Sd|e`

先变换成直接左递归

`S->Aa|b`

`A->Aad|bd|e`

再消除左递归

`S->Aa|b`

`A->bdA'|A'`

`A'->adA'|e`

###提左因子
**ex:**

`stmt -> if expr then stmt else stmt | if expr then stmt | other`

提左因子：（这里用e代替yibuxilong）

`stmt -> if expr then stmt optional_else_part | other`

`optional_else_part -> else stmt | e `


###NFA->上下文无关文法

* 确定终结符集合
* 为每个状态引入一个非终结符Ai
* 如果状态i有一个a转换到状态j,引入产生式Ai->aAj,如果i是接受状态，则引入Ai->e (e代表yibuxilong)


#####上下文无关文法的优点 
* 文法给出了精确的，易于理解的语法说明
* 自动产生高效的分析器
* 可以给语言定义出层次结构
* 以文法为基础的语言的实现便于语言的修改

#####上下文无关文法的缺点
* 文法只能描述编程语言的大部分语法



###3.2 自上而下分析
###First&Follow
**这里用e代替yibuxilong**
####FIRST集合计算方法
* 若X->a..， 则将终结符ａ加入FIRST(X)中
* 若X->e，则将e加入FIRST(X)中
* 若X->Y…，且Y属于非终结符，则将FIRST(Y)\{e}加入到FIRST(X)中
* 若X->Y1Y2..YK,且Y1,Y2,..Yi-1都是非终结符，且Y1,Y2,..Yi-1的FIRST集合中均包含e，则将FIRST(Yj)的所有非e元素加入到FIRST(X)中，（j=1,2,..i）.特别地，若Y1~YK均有e产生式，则将e加到FIRST(X)中。

####FOLLOW集合计算方法
* 对文法开始符号S,置$于FOLLOW(S)中。
* 若有A->aBb，则将FIRST(b)\{e} 加入FOLLOW(B)中。 （此处a可以为空）
* **若A->aB 或A->aBb,且 b=>*e（即e属于FIRST(b)）,则将 FOLLOW(A)加入FOLLOW(B)中（此处 可以为空）。**

###LL(1) 文法
* 对于任何产生式`A->a|b`必须满足一下条件 
* FIRST(a) 交 FIRST(b) = 空集（ FIRST (ai ) 和 FIRST (bj )都不含e）。
* 若b =>* e ，那么FIRST(a) 并 FOLLOW(A) = 空集。 
* **该文法不能是二义的，不能是左递归，不能提左因子**

####预测分析
* 递归的分析
* 非递归的预测分析
	* **构造LL(1)文法分析表**，注意输入符号中有**$**符。
		* 对文法的每个产生式A -> a ，执行2和3。
		* 2.对FIRST(a)的每个终结符a，把A -> a 加入M[A, a]（即加入表中A行a列）。
		* 3.如果e在FIRST(a)中，对FOLLOW(A)的每个终结符b（包括$）, 把A -> a加入M[A, b]。
		* M的其它没有定义的条目都是error。  
	*  顺序输入接受串，按照文法表构造分析栈，**注意如果按`E-> TE' `压栈，则先将E弹出，然后按 E'T 压栈，因为栈是先进后出。**
	
**构造的LL(1)文法表有多重定义的条目，说明该文法不是LL(1)文法，这可以用于LL(1)文法的证明**

####非上下文无关的文法 
>0型文法 > 1型文法 > 2型文法 > 3型文法
	
###3.3 自下而上分析
**归约:**最右推导的逆过程。

####句柄
*　句柄与某个产生式的右部符号串相同
* 句柄是句型的一个子串
* 把句柄归约成非终结符代表了最右推导逆过程的一步
* 句柄的右侧只含有终结符，如果文法二义，那么句柄可能不唯一。
* 推导出谁谁是句柄，谁被规约谁是句柄。

####两种冲突
* 移进和规约的冲突
* 规约和规约的冲突

###LR分析器
**LR和LL的第一个L代表它们都是从左向右扫描，第二个代表它们的推导方式，R代表最右推导，L代表最左推导**
####特点：
* 适用于一大类上下文无关文法
* 效率高

####主要介绍构造LR分析表的三种技术
* 简单的LR方法（简称SLR）
* 规范的LR方法
* 向前搜索的LR方法（简称LALR）  

#####LR分析方法的特点
* 栈中的文法符号总是形成一个活前缀。
* 分析表的转移函数本质上是识别活前缀的DFA。
* 栈顶的状态符号包含了确定句柄所需要的一切信息。
* 是已知的最一般的无回溯的移进归约方法。
* 能分析的文法类是预测分析法能分析的文法类的真超集。
* 能及时发现语法错误。
* 手工构造分析表的工作量太大。

**活前缀**：右句型的前缀，该前缀不超过最右句柄的右端

###SLR分析器
#####构造SLR分析表的两大步骤
* 利用文法来构造一个能够识别活前缀的DFA
	* 拓广文法
	* 构造LR(0)项目集规范族，涉及到各种闭包和状态，**这里千万要细心**。
		* 在一个状态中，求**所有点**后面非终结符的闭包，加入该状态。
		* 在一个状态中，每识别一个符号到达一个**新的状态**，每个状态都得重复上一步。
		* 列出所有状态。 
* 从上述DFA**构造分析表** 
	* 动作表
		* **移进**，如果[A->·ab]在Ii中，并且goto(Ii,a) = Ij，那么置action[i, a]为sj。
		* **规约**,如果[A->a·]在Ii中，那么对**FOLLOW(A)**中的所有a，置action[i, a]为rj,j是产生式 A->a的编号,编号从一开始，拓广文法没有编号。
		* 如果[S->S·]在Ii中，那么置action[i,$]为接受acc。
		* **如果出现动作冲突，那么该文法就不是SLR(1)的。**
 	* 转移表
 		* 对所有的非终结符A，如果goto(Ii, A) = Ij, 那么goto[i, A] = j。 
 	* 表中空出的地方就是error。


核心项目：点不在**左端**的项目。

非核心项目：通过对核心项目求闭包而获得，所以点在最左端。

###LR(1)分析器
####构造规范的LR分析表（带上了搜索符）
搜索符：在**规约**的时候有用。规约时，只有**看到**在对应的搜索符中存在的符号时才能规约。

求搜索符：

* 1.搜索符根据父项目求。注意父项目可能有多个。
> ##ex.
> ###`[S->.BaA,$]` 和 `E->.B,a` 都在同一状态中，且都是 `B->.a` 的父项目，那么 `B->a`的搜索符为 First(aA)+First(e)。

* 2.到达另一个状态之后，首个产生式的搜索符和识别前的产生式保持一致。

####动作表
* 如果[A->·ab,c]在Ii中，且goto(Ii, a) = Ij ，那么置action[i, a]为sj。
* 如果[A->a·,c]在Ii中，且A != S'，那么置action[i,c]为rj .
* 如果[S'->S·, $]在Ii中，那么置action[i, $] = acc。

LR(1)和LR其实只有**规约**有少量区别。**前提是把表画对！**

###LALR分析表
* LALR和SLR的分析表有同样多的状态，而规范LR分析表要大得多。
* LALR的能力介于SLR和规范LR之间。

####构造LALR
在LR(1)的基础上合并**同心集**，即略去搜索符后它们是相同的集合，并把这些同心集合并成一个项目集。

对于LR(1)文法，如果把所有的同心集合并，有可能导致冲突。但是这种冲突只可能是规约-规约的冲突，不可能是移进-规约的冲突。

####LR分析器在什么情况下发现错误
* 访问动作表时若遇到出错条目
* 访问转移表时它决不会遇到出错条目
* 决不会把不正确的后继移进栈
* 规范的LR分析器甚至在报告错误之前决不做任何无效归约

##四.语义指导的翻译
本章建议跟着课本来一遍。

语义分析的任务：语义分析的输入是语法分析的输出（分析树），**输出是中间代码**，但同时它还完成了很多语义处理工作。

* 语义检查：如，类型、运算、维数、越界等。
* 语义处理：如，变量的存储分配、表达式的求值、语句的翻译（中间代码的生成）等。
* 总目标：生成等价的中间代码。

**语义分析的主流技术**：语法制导翻译技术。

###4.1 属性文法(也称属性翻译文法)
* 在上下文无关文法的基础上，为每个文法符号（终结符或非终结符）配备若干相关的“值”（称为属性）。
	* 属性代表与文法符号相关信息，如类型、值、代码序列、符号表内容等。
	* 属性可以进行计算和传递。
	* **语义规则**：对于文法的每个产生式都配备了一组属性的计算规则。

**语法制导**的定义是带**属性和规则的上下文无关文法**。

**语法制导**：基于语法分析中用到的文法产生式。　　　

**翻译**：完成语义分析的各项功能，不仅指生成中间代码。

在语法制导定义中的文法被称为**基础文法**。

####属性
每个文法产生式A－＞ａ有一组形式为b := f(c1, c2, …, ck )的语义规则，其中f 是函数，b和c1, c2, …, ck 是该产生式文法符号的属性

* **综合属性：**如果b是A的属性，c1 , c2 , …, ck 是产生式右部文法符号的属性或A的其它属性。
* **继承属性：**如果b是产生式右部某个文法符号X的属性。
* 以上两种情况下，都说b依赖于属性c1 , c2 , …, ck 。
* 由函数或者词法分析器提供的属性是**综合属性**。

**注意：**

* 终结符号只有综合属性，他们由词法分析器提供。
* 非终结符号既有综合属性也可有继承属性，文法的开始符号没有继承属性，除非另外加以说明。
* 文法符号的综合属性集和继承属性集的交集应为空。
* 对出现在产生式右边的继承属性和出现在产生式左边的综合属性都必须提供一个计算规则。属性计算规则中只能使用相应产生式中的文法符号的属性。
* 出现在产生式左边的继承属性和出现在产生式右边的综合属性不由所给的产生式的属性计算规则进行计算，它们由**其它产生式**的属性规则计算或者由属性计算器的参数提供。

**注释分析树**：每个结点的属性值都标出来的分析树。

####继承属性
* 在语法树中，一个结点的继承属性由此结点的父结点和/或兄弟结点的某些属性确定。
* 用继承属性来表示程序设计语言结构中的上下文依赖关系很方便。

**属性依赖图：**在一棵分析树中的结点的继承属性和综合属性之间的相互依赖关系可以由称作依赖图的一个有向图来描述。

**拓扑排序：**结点的一种排序，使得边只会从该次序中先出现的结点到后出现的结点。

如果一属性文法不存在属性之间的循环依赖关系，那么称该文法为**良定义的**。

一个依赖图的任何拓扑排序都给出一个语法树中结点的语义规则计算的有效顺序。

* 基础文法用于建立输入符号串的语法分析树；
* 根据语义规则建立依赖图
* 从依赖图的拓扑排序中，我们可以得到计算语义规则的顺序。

输入串->分析树->依赖图->语义规则计算次序
 
###属性计算次序
1. 构造输入的分析树
2. 构造属性依赖图
3. 对结点进行拓扑排序
4. 按拓扑排序的次序计算属性

##语法树

###S属性的自下而上计算
采用自底向上分析，例如LR分析，首先给出S-属性定义，然后，把S-属性定义变成可执行的代码段，这就构成了翻译程序。象一座建筑，语法分析是构架，归约处有一个“挂钩”，语义分析和翻译的代码段（语义子程序）就挂在这个钩子上。这样，随着语法分析的进行，归约前调用相应的语义子程序，完成翻译的任务。

###L属性定义的自上而下计算 LL(1)
如果每个产生式A -> X1 X2 … Xn 的每条语义规则计算的属性是A的综合属性；或者是Xj 的继承属性，1 <= j <= n, 但它仅依赖：

* 该产生式中Xj左边符号X1, X2, …, Xj-1的属性；
* A的继承属性。

>S属性定义属于L属性定义。

####翻译方案
**翻译方案**给出了使用语义规则进行计算的次序，这样就可把某些实现细节表示出来。

* 在翻译方案中，和文法符号相关语义动作，用花括号{ }括起来，插入到产生式右部的合适位置上。
* 这是一种动作和分析交错的方法，以表示动作的执行时机。

**L属性**定义的翻译方案的**三条限制**：

* 产生式右部符号的继承属性必须在先于这个符号的动作中计算
* 一个动作不能引用该动作右边符号的综合属性
* 左部非终结符的综合属性只能在它所引用的所有属性都计算完后才能计算

###建立翻译模式
* 当只需要综合属性时：为每一个语义规则建立一个包含赋值的动作，并把这个动作放在相应的产生式右边的末尾。

>产生式			  语义规则
>>T→T1*F		T.val:=T1.val×F.val
>
>建立产生式和语义动作：
>>T→T1*F	    {T.val:=T1.val×F.val}

* 如果既有综合属性又有继承属性，在建立翻译模式时就必须保证：
	1. 产生式右边的符号的继承属性必须在先于这个符号的动作中计算出来。
	2. 一个动作不能引用这个动作右边的符号的综合属性。
	3. 产生式左边非终结符的综合属性只有在它所引用的所有属性都计算出来以后才能计算。计算这种属性的动作通常可放在产生式右端的末尾。

###L属性的自下而上计算 
在自下而上语法分析的框架中实现L属性定义的方法，可以做到：

* 实现任何基于LL(1)文法的L属性定义。
* 实现许多（但不是所有的）基于LR(1) 的L属性定义。

####删除翻译方案中嵌入的动作
在L属性的翻译方案中引入**标记非终结符**代替原来的翻译方案。形如：`E-> e {print('+');}`。这样文法接受同样的语言，并且对任何输入，它们执行的语义动作都是一样的。而且能使动作仅在规约时进行，这样可以实现在栈里保存了继承属性。

灵活运用**标记非终结符**。

####分析栈上的继承属性
#####确定继承属性所继承的属性位置
确认位置可以直接从栈中的对应位置取得属性值。

这里涉及到复写规则，简单的说，复写就是copy，即把所要继承的属性值copy给继承属性.

#####不能预测继承属性所继承的属性的位置
在相应的非终结符前加入**标记非终结符**记录所需的属性，详情参考p125。

####模拟继承属性的计算
这里涉及的可能是比复写复杂的计算规则。方法还是加入**标记非终结符**。

##六 运行时存储空间的组织和管理
编译程序每次运行时，编译器从操作系统（OS）获得一块存储区（内存）。其内容包括：

* 编译后的目标代码 (可执行程序 .exe)
* 数据对象 (各种静态变量和动态变量)
* 用于管理过程活动的控制栈 (活动记录)

####局部数据的安排

* 字节是可编址内存的最小单位。
* 一个过程所声明的局部变量，按这些变量声明时出现的次序，在活动记录的局部数据区中依次分配空间。 
* 局部数据的地址可以用相对于某个位置（本过程对应的活动记录的起始位置）的偏移来表示。
* 数据对象的存储安排深受目标机器寻址方式的影响，存在对齐问题。例如，要求整数（int，long）的相对地址可以被4整除。由于对齐而引起的无用空间称为衬垫空白区。



###三种分配策略
####静态分配
	
* 名字在程序被编译时绑定到存储单元，不需要运行时的任何支持。
* 绑定的生存期是程序的整个运行时间。
* 控制再次进入该过程时，局部变量的值和控制上一次离开时的一样。
* 每个活动记录的大小是固定的。
* 过程调用时保存信息的地址在编译时也是已知的。
	>EX
	* 声明在函数外面
		* 外部变量
	* 声明在函数里面
		* 静态局部变量
		* 常量
 
####栈式分配
* 栈式分配主要用于管理过程的活动记录。
* 局部变量的生存期是过程活动的时间。
* 控制进入该过程时，局部变量绑定到存储单元，过程活动结束后，局部变量的空间释放。

#####活动树
>用树来描绘控制进入和离开活动的方式

活动树的特点(深度优先搜索)

* 每个结点代表某过程的一个活动
* 根结点代表主程序的活动
* 结点a是结点b的父结点，当且仅当控制流从a的活动进入b的活动
*　结点a 处于结点b 的左边，当且仅当a的生存期先于b的生存期



计这些（看课件）序列和活动记录的一些原则是

* 把参数域和可能有的返回值域放在紧靠调用者活动记录的地方
* 以活动记录中间的某个位置作为基地址
* 长度能较早确定的域放在活动记录的中间
* 一般把临时数据域放在局部数据域的后面
* 用同样的代码来执行各个活动的保存和恢复


####堆式分配
用户自己申请空间，自己释放空间

