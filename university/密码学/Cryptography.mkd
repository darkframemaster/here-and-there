#Cryptography and Network Security

###安全攻击
对任何机构的信息资源进行破坏的行为即为安全攻击。

####攻击分类
* 被动攻击试图了解或者利用系统的信息但不影响系统资源。被动攻击的**特性**是对传输进行**窃听和监测**。
	* 消息内容的泄漏
	* 流量分析
* 主动攻击包括对数据流进行**修改或者伪造数据流**，可分为四类。
	* 伪装
	* 重播
	* 消息修改
	* 拒绝服务。
 
###安全服务
####认证
认证服务与保证通信的真实性有关。认证服务功能是向接收方保证消息来自所声称的发送方。

####访问控制
访问控制是一种限制和控制那些通过通信连接对主机和应用进行访问的能力。每个试图获得访问控制的实体必须被识别或认证后才能获取其相应的访问权限。

####数据保密性
保密性的目的是防止传输的数据遭到被动攻击。

####数据完整性
完整性服务和**主动攻击**有关。面向连接的完整性服务处理消息流的**修改和拒绝服务**两个问题，无连接的完整性服务，仅仅处理单条消息，而不管大量的上下文信息，通常仅仅防止对单条消息的**修改**。

####不可否认性
防止发送方或接收方否认传输或者接收过某条消息。

###安全机制
加密，数字签名，访问控制，数据完整性，认证交换，流量填充，路由控制，公证。

##chapter two:传统加密技术
对密码的两种攻击方法：基于密码算法性质的**密码分析** 和 基于穷举密钥的**穷举攻击**。

####对称密码模型

##chapter three:分组密码和数据加密标准
分组加密：将一个明文分组作为整体加密并且通常得到的是与明文等长的密文分组。
###Feistel密码
Feistel建议使用这样的密码：该种密码交替地使用**代替和置换**。

Feistel结构由许多相同的轮函数组成。每一轮里，对输入数据的一半进行代换，接着用一个置换来交换数据的两个部分，扩展初始的密钥使得每一轮使用不同的子密钥。DES是应用最为广泛的分组密码，展现了经典的Feistel结构。

Feistel的参数和特征：

* 分组长度
* 密钥长度
* 迭代轮数
* 字密钥产生算法
* 轮函数F

设计Feistel密码还需考虑的其他问题：

* 快速软件加/解密
* 简化分析难度

###DES:数据加密标准
注意**混淆和扩散**的思想。

DES加密的明文长为64位，密钥长为56位。DES加密的三个阶段：初始置换->16轮相同函数的作用->逆初始置换。

DES的置换和代替（即混淆和扩散的应用）都在16轮相同的函数处理中。(详见课本P57)


##chapter 6:分组密码的工作模式
####双重DES
进行连续两次加密。

```
C=E(K2,E(K1,P))
P=D(K1,D(K2,C))
```

但是有中途相遇攻击"meet-in-the-middle",只要是连续使用密码两次，这种攻击总是有效的。

* 原理：`X=E(K1,P)=D(K2,C)`
* 方法：
    * 用所有可能的密钥加密明文P并把结果存储起来
    * 然后用所有可能的密钥解密密文C，寻找匹配的X值。   
* 复杂度：相比于单次加密的处理，双重处理只是多出了对密文的一次解密处理，因此复杂度仅为单次的两倍。

####两个密钥的三重DES
在双重加密的基础上用K1再进行一次加密。
```
C=E(K1,E(K2,E(K1,P)))
```
目前没有对三重DES的可行攻击方法。


####三个密钥的三重DES
密钥越多安全性越高。

###分组密码的工作模式
请参考第六章的ppt
<table border="1">
    <tr><th>模式</th><th>描述</th><th>典型应用</th><th>优缺点</th></tr>
    <tr><td>电码本(ECB)</td><td>用相同的密钥分别对明文分组独立加密</td><td>单个数据的安全传输，多个或者较长的数据不安全</td><td>过于简单</td></tr>
    <tr><td>密文分组连接(CBC)</td><td>加密算法的输入是上一个密文组和下一个密文组的异或</td><td> 面向分组的通用传输  以及 认证</td><td>1.明文消息的任何一点变化将会影响怎个密文分组 2.发送方和接收方要共享IV</td></tr>
    <tr><td>密码反馈模式(CFB)</td><td>一次处理s位，上一块密文作为加密算法的输入，产生的伪随机数输出与明文异或作为下一单元的密文</td><td>面向数据流的通用传输 以及 认证</td><td>1.当数据以位或字节形式到达时使用 2.最通用的是流密码形式 3.明文变化的影响依然很大</td></tr>
    <tr><td>输出反馈(OFB)</td><td>与CFB类似，只是加密算法的输入是上一次加密的输出，而且使用整个分组</td><td>噪声信道上的数据流传输</td><td>1.传输过程中在某位发生错误不会影响到其他位 2.抗消息流篡改攻击的能力不如CFB</td></tr>
    <tr><td>计数器(CTR)</td><td>每个明文文组都与一个经过加密的计数器相异或。对每个后续分组计数器递增</td><td>面向分组的通用传输 用于高速需求</td><td>1.高效 2.可以对被加密的分组进行随机存取 3.相当安全 4.简洁 5.必须绝不重复使用密钥和计数器值</td></tr>
</table>

##chapter 8:数论入门
###费马定理和欧拉定理
###中国剩余定理

##chapter 9:公钥密码学与RSA
人物：Diffie & Hellman
####对称密码体制和非对称密码体制
* 对称密码体制的问题
    * 加密能力与解密能力是捆绑在一起的
    * 密钥更换、传递和交换需要可靠信道，密钥分发困难
    * 密钥管理困难
    * 无法满足不认识的人之间通信的保密要求
    * 不能实现数字签名
* 公钥密码体制的特点
    *  加密能力与解密能力是分开的
    *  密钥分发简单
    *  需要保存的密钥量大大减少，N个用户N个密钥
    *  可以满足不认识的人之间保密通信
    *  可以实现数字签名
   
###公钥密码体制的应用
* 加密/解密：发送方用接收方的公钥对消息进行加密
    * RSA（大数分解问题） 
* 数字签名：发送方用其私钥对消息签名，可以对整体消息签名或者对消息的摘要签名。
    * Hash
    * ElGamal数字签名
* 密钥交换：通行双方交换会话密钥。
    * ElGamal密钥交换（离散对数问题）
    
###RSA算法
人物： Rivest & Shamir & Adleman

####算法流程
* 随机选择两个秘密大素数 p 和 q
* 计算公开模数 n = p*q
* 计算秘密的欧拉指数函数 fan(n) = (p-1)(q-1)
* 选一个与 fan(n) 互素的数，作为 e 或 d （这里选择e）
* 求出 e mod fan(n) 的逆元，作为 d （选d同理）
* 加密m：C = m^e mod n
* 解密：m = C^d  mod n

证明：略

##chapter 10:密钥管理和其他公钥体制
###公钥的分配
* 自由的公钥发布
* 公开可访问的目录（由管理员管理公钥）
* 公钥授权（管理员管理公钥，提供其他认证）
* 公钥证书（管理员提供公钥证书）

###利用公钥密码分配传统密码体制的密钥
* 简单的密钥分配（不安全，中间人攻击）
* 具有保密性和真实性的密钥分配（在传送公钥时提供加密）

###Diffle-Hellman密钥交换
基于离散对数问题。

* A B 双方共享一个大素数 p 和模p的一个素根 a
* 各自生成公钥 yA = a^xA mod p（B同理）
* 会话密钥KAB = a^xAxB mod p（A B中的任意一方可以同个自己的私钥和对方的公钥进行计算）
* KAB是双方用**对称密码**通信是的共享密钥。

无法抵抗中间人攻击，攻击者生成两个随机的私钥伪装成通信的双方。

###ElGamal的概率密码系统
* A B通信共享大素数 p ，本原元素 a，0 <= m <= p-1
* 加密：
    * A选择一个随机的 k (0 <= k <= p-1)，并取得B的公钥（YB = a^xB mod p）。 
    * K = (YB)^k mod p （K相当于会话密钥：K = a^kxB mod p）
    * C1 = a^k mod p
    * C2 = mK mod p
    * 密文：（C1,C2）  
* 解密：
    * K = (C1)^xB mod p 
    * m = C2K^-1 mod p
   
##chapter 11:消息认证 和 Hash函数
消息认证是用来验证消息**完整性**的一种机制或服务。消息认证确保收到的数据确实和发送时的一样（没有修改、插入、删除或重放），且发送方声称的**身份是真实有效**的。

用于消息认证的最常见的密码技术是**消息认证码和安全散列函数**。

###报文认证
* 消息认证（报文认证）关心的问题是：
    * 保护消息的完整性
    * 验证发起方身份
    * 消息源的不可否认
* 三种消息认证方法：
    * 消息加密
    * 消息认证码（MAC）
    * Hash函数
    
####消息加密
* 私钥加密实现认证、签名。
* 对方公钥加密实现保密。

###消息认证码 MAC
MAC的生成依赖与通信双方共有的密钥  K。

* 报文认证不提供保密（即 MAC 码的单独运用没有保密性）
* MAC函数类似加密，但不是数字签名，无需可逆
* 将 MAC 直接与明文并置，然后加密传输比较常用

###散列函数 Hash Func
散列码的生成依赖于一个Hash函数，具有查错检测能力，报文任意一bit的改变都将引起散列码的改变。

对Hash函数的要求：

* 可以用于任意大小的数据块
* 产生固定长度的输出
* 给定明文 x 容易计算其Hash值 H(x)
* 对任意给定的散列码h，找到满足 H(x)=h 的x，在计算上不可行，**单向性**
* 对任意给定的分组x，找到满足 y != x 且 H(x)  == H(y) 的y，在计算上不可行，**抗弱碰撞性**
* 找到任何满足 H(x) = H(y) 的偶对 (x, y)，在计算上不可行，**抗强碰撞性**

##chapter 13:数字签名 和 认证协议
 数字签名是一种认证机制。签名保证了消息的来源和完整性。
 
###数字签名的基本形式
* 数字签名与消息认证的区别
    * 消息认证是使消息的接收方验证消息发送者发送的内容有无被修改过，对防止第三者破坏足够，但收发双方有利害冲突的时候就无能为力，需要更严格的手段，即数字签名。
* 数字签名的基本形式
    * 对消息签名的两种方式
        * 对消息的整体签字
        * 对消息的摘要签字
    * 两类数字签名
        * 确定性数字签名，明文与签名一一对应
        * 概率性数字签名，一个明文可以有多个合法签名，每次都不一样。
        
###ElGamal数字签名验证
* 通信的双方共享大素数 p 和一个 素根 a  
* 假设 A 向 B 发送明文 m 的签名, YA = a^xA mod p, YB = a^xB mod p 
* A选择一个随机的 k (0 <= k <= p-1)
* A 签名：
    * S1 = a^k mod  p
    * S2 = k^-1 (m - xAS1) mod (p-1)
    * 发送签名(S1,S2)
* B 认证签名：
    * v1 = a^m mod  p
    * v2 = (YA)^S1 (S1)^S2 mod p   

  